"use strict";(self.webpackChunk_typed_inject_website=self.webpackChunk_typed_inject_website||[]).push([[21],{1065:(e,t,r)=>{r.d(t,{z:()=>n});const n=[String,Object,Symbol,Array,Number]},2466:(e,t,r)=>{r.d(t,{I:()=>n});const n=Symbol("EMPTY_VALUE")},3471:(e,t,r)=>{r.d(t,{G:()=>n});const n={multiple:!1,eager:!1,scope:"container",value:r(2466).I,factory:void 0}},2303:(e,t,r)=>{r.d(t,{L:()=>m});class n{static registerContainer(e){if(e instanceof m==!1)throw new Error("Only ContainerInstance instances can be registered.");if(n.containerMap.has(e.id))throw new Error("Cannot register container with same ID.");n.containerMap.set(e.id,e)}static hasContainer(e){return n.containerMap.has(e)}static getContainer(e){const t=this.containerMap.get(e);if(void 0===t)throw new Error("No container is registered with the given ID.");return t}static async removeContainer(e){const t=n.containerMap.get(e.id);if(void 0===t)throw new Error("No container is registered with the given ID.");n.containerMap.delete(e.id),await t.dispose()}}n.containerMap=new Map;var i=r(9893);class a extends Error{get message(){return`Service with "${this.normalizedIdentifier}" identifier was not found in the container. Register it before usage via explicitly calling the "Container.set" function or using the "@Service()" decorator.`}constructor(e){super(),this.name="ServiceNotFoundError",this.normalizedIdentifier="<UNKNOWN_IDENTIFIER>","string"==typeof e?this.normalizedIdentifier=e:e instanceof i.W?this.normalizedIdentifier=`Token<${e.name||"UNSET_NAME"}>`:e&&(e.name||e.prototype?.name)&&(this.normalizedIdentifier=`MaybeConstructable<${e.name}>`||`MaybeConstructable<${e.prototype?.name}>`)}}var s=r(1854),o=r(2466),l=r(1065),c=r(276),d=r(3471),u=r(3809);const p=new i.W("Host Container"),h="throwIfDisposed",f=[p];class m{constructor(e,t){this.parent=t,this.metadataMap=new Map,this.multiServiceIds=new Map,this.disposed=!1,this.id=e}has(e,t=!0){if(this[h](),f.includes(e))return!0;const r=this.getIdentifierLocation(e);return!(!t||"parent"!==r)||"local"===r}getIdentifierLocation(e){return this[h](),this.metadataMap.has(e)||this.multiServiceIds.has(e)?"local":this.parent&&this.parent.has(e,!0)?"parent":"none"}get(e,t){const r=this.getOrNull(e,t);if(null===r)throw new a(e);return r}resolveMetadata(e,t){this[h]();const r=this.getIdentifierLocation(e);switch(r){case"none":return null;case"local":return[this.metadataMap.get(e),r];case"parent":if(t){const t=this.parent?.resolveMetadata(e,!0);return t?[t[0],"parent"]:null}return null}}getOrNull(e,t=!0){if(this[h](),e===p)return this;const r=this.resolveMetadata(e,t);if(null===r)return null;const[n,i]=r;if("parent"===i){const r="singleton"===n.scope?n.value:o.I,i={...n,value:r};if("singleton"===i.scope)return m.defaultContainer.getOrNull(e,t);const a=this.set(i,[...n.dependencies]);return this.getOrNull(a,t)}let a=n;if("singleton"===n?.scope&&(a=m.defaultContainer.metadataMap.get(e)),a&&!0===a.multiple)throw new Error(`Cannot resolve multiple values for ${e.toString()} service!`);return a?this.getServiceValue(a):null}getMany(e,t){const r=this.getManyOrNull(e,t);if(null===r)throw new a(e);return r}getManyOrNull(e,t=!0){let r;if(this[h](),this.multiServiceIds.has(e)?r=this.multiServiceIds.get(e):t&&this.parent&&this.parent.multiServiceIds.has(e)&&(r=this.parent.multiServiceIds.get(e)),!r)return null;const n="singleton"===r.scope?e=>m.defaultContainer.get(e):e=>this.get(e,t);return r.tokens.map(n)}set(e,t){if(this.throwIfDisposed(),"singleton"===e.scope&&m.defaultContainer!==this)return m.defaultContainer.set(e,t);const r=t??e?.dependencies?.map(u.B)??[],n={id:e.id??e.type,type:null,...d.G,...e,dependencies:r};if(n.multiple){const e=new i.W(`MultiMaskToken-${n.id.toString()}`),t=this.multiServiceIds.get(n.id);t?t.tokens.push(e):this.multiServiceIds.set(n.id,{scope:n.scope,tokens:[e]}),n.id=e,n.multiple=!1}return this.metadataMap.set(n.id,n),n.eager&&"transient"!==n.scope&&this.get(n.id),n.id}remove(e){if(this[h](),Array.isArray(e))e.forEach((e=>this.remove(e)));else{const t=this.metadataMap.get(e);t&&(this.disposeServiceInstance(t),this.metadataMap.delete(e))}return this}static of(e="default",t=m.defaultContainer){if("default"===e)return this.defaultContainer;let r;return n.hasContainer(e)?r=n.getContainer(e):(r=new m(e,t??void 0),n.registerContainer(r)),r}of(e){return m.of(e)}ofChild(e){return this[h](),m.of(e,this)}reset(e={strategy:"resetValue"}){switch(this[h](),e.strategy){case"resetValue":this.metadataMap.forEach((e=>this.disposeServiceInstance(e)));break;case"resetServices":this.metadataMap.forEach((e=>this.disposeServiceInstance(e))),this.metadataMap.clear(),this.multiServiceIds.clear();break;default:throw new Error("Received invalid reset strategy.")}return this}async dispose(){this[h](),this.reset({strategy:"resetServices"}),this.disposed=!0}throwIfDisposed(){if(this.disposed)throw new Error("Cannot use container after it has been disposed.")}getServiceValue(e){let t=o.I;const{factory:r}=e;if(e.value!==o.I)return e.value;if(!r&&!e.type)throw new s.Z(e.id);if(r)if(Array.isArray(r)){const[n,i]=r;t=(this.getOrNull(n)??new n)[i](this,e.id)}else t=r(this,e.id);if(!r&&e.type){t=new(0,e.type)(...this.getConstructorParameters(e,!0))}if("transient"!==e.scope&&t!==o.I&&(e.value=t),t===o.I)throw new s.Z(e.id);return t}getConstructorParameters({dependencies:e},t){return 0===e.length?[]:e.map((e=>this.resolveResolvable(e)))}resolveResolvable(e){const t=this.resolveTypeWrapper(e.typeWrapper);if(e.constraints){const{constraints:r}=e;let n;const i=!!(2&r),s=!!(4&r),o=!!(8&r),l=!!(1&r);if(s&&o)throw new Error("SkipSelf() and Self() cannot be used at the same time.");if(s&&!this.parent)throw new Error("The SkipSelf() flag was enabled, but the subject container does not have a parent.");const c=s?this.parent:this,d=!o??void 0;if(!c.has(t,d)){if(i)return null;throw new a(t)}return n=l?c.getMany(t,d):c.get(t,d),n}return this.get(t)}resolveTypeWrapper(e,t=!1){const r=e.eagerType??e.lazyType?.();if(null==r)throw new Error("The wrapped value could not be resolved.");if(t&&l.z.includes(r))throw new c.m(r?.name??r);return r}disposeServiceInstance(e,t=!1){this[h]();if(t||!!e.type||!!e.factory){if("function"==typeof(e?.value).dispose)try{e.value.dispose()}catch(r){}e.value=o.I}}[Symbol.iterator](){return this.metadataMap.entries()}}m.defaultContainer=new m("default"),n.registerContainer(m.defaultContainer)},8772:(e,t,r)=>{r.d(t,{t:()=>c});var n=r(2303);function i(e){return String(e.name||e)}var a=r(3471),s=r(1065),o=r(276),l=r(3809);function c(e,t){return r=>{if(null==e)throw new Error("The required configuration was not passed.");let c;if(Array.isArray(e)?c=e:Array.isArray(t)?c=t:"dependencies"in e&&(c=e.dependencies),!c)throw new Error("The dependencies provided were not able to be resolved.");const d=c.map(l.B);let u={id:r,type:r,...a.G,container:n.L.defaultContainer};Array.isArray(e)||(u={...u,...e},delete u.dependencies);const{id:p,container:h}=u;if(h.has(p)&&h.get(p)===r)throw new Error(`@Service() has been called twice upon ${i(r)}, or you have used an ID twice.`);d.forEach((({typeWrapper:e},t)=>{const{eagerType:n}=e;if(null!==n){const a=typeof e;if("function"!==a&&"object"!==a&&"string"!==a)throw new Error(`The identifier provided at index ${t} for service ${i(r)} is invalid.`);if(null==u.factory&&s.z.includes(n))throw new o.m(n?.name??n)}})),h.set(u,d)}}},276:(e,t,r)=>{r.d(t,{m:()=>i});var n=r(1854);class i extends n.Z{get message(){return super.message+" If your service requires built-in or unresolvable types, please use a factory."}}},1854:(e,t,r)=>{r.d(t,{Z:()=>i});var n=r(9893);class i extends Error{get message(){return`Cannot instantiate the requested value for the "${this.normalizedIdentifier}" identifier. The related metadata doesn't contain a factory or a type to instantiate.`}constructor(e){super(),this.name="CannotInstantiateValueError",this.normalizedIdentifier="<UNKNOWN_IDENTIFIER>","string"==typeof e?this.normalizedIdentifier=e:e instanceof n.W?this.normalizedIdentifier=`Token<${e.name||"UNSET_NAME"}>`:e&&(e.name||e.prototype?.name)&&(this.normalizedIdentifier=`MaybeConstructable<${e.name}>`||`MaybeConstructable<${e.prototype?.name}>`)}}},9435:(e,t,r)=>{function n(){return 2}r.d(t,{Fi:()=>n})},7877:(e,t,r)=>{r.d(t,{W2:()=>n,ZP:()=>i});const n=r(2303).L.defaultContainer,i=n},9893:(e,t,r)=>{r.d(t,{W:()=>n});class n{constructor(e){this.name=e}}},3809:(e,t,r)=>{r.d(t,{B:()=>o});var n=r(9893);const i=Symbol("LAZY_REFERENCE"),a=Symbol("INJECTED_FACTORY");function s(e){let t;return e&&("string"==typeof e||e instanceof n.W||"function"==typeof e)?t={eagerType:e,lazyType:()=>e,isFactory:!1}:"object"==typeof e&&!0===e[a]?t={eagerType:null,factory:e,isFactory:!0}:e&&function(e){return!0===e[i]}(e)&&(t={eagerType:null,lazyType:()=>e.get(),isFactory:!1}),t}function o(e){let t,r;if(Array.isArray(e)){const[n,i]=e;if(null==n||null==i)throw new Error("The dependency pair was not instantiated correctly.");"number"==typeof i&&(t=i),r=s(n)}else r=s(e);return{constraints:t,typeWrapper:r}}},8450:(e,t,r)=>{r.d(t,{Z:()=>f});var n=r(1966),i=r(9496),a=r(5924),s=r(306),o=r(4969);const l={details:"details_YVtT",isBrowser:"isBrowser_B1Ku",collapsibleContent:"collapsibleContent_mCB7"};function c(e){return!!e&&("SUMMARY"===e.tagName||c(e.parentElement))}function d(e,t){return!!e&&(e===t||d(e.parentElement,t))}function u(e){let{summary:t,children:r,...u}=e;const p=(0,s.Z)(),h=(0,i.useRef)(null),{collapsed:f,setCollapsed:m}=(0,o.u)({initialState:!u.open}),[y,g]=(0,i.useState)(u.open),w=i.isValidElement(t)?t:i.createElement("summary",null,t??"Details");return i.createElement("details",(0,n.Z)({},u,{ref:h,open:y,"data-collapsed":f,className:(0,a.Z)(l.details,p&&l.isBrowser,u.className),onMouseDown:e=>{c(e.target)&&e.detail>1&&e.preventDefault()},onClick:e=>{e.stopPropagation();const t=e.target;c(t)&&d(t,h.current)&&(e.preventDefault(),f?(m(!1),g(!0)):m(!0))}}),w,i.createElement(o.z,{lazy:!1,collapsed:f,disableSSRStyle:!0,onCollapseTransitionEnd:e=>{m(e),g(!e)}},i.createElement("div",{className:l.collapsibleContent},r)))}const p={details:"details_x2f9"},h="alert alert--info";function f(e){let{...t}=e;return i.createElement(u,(0,n.Z)({},t,{className:(0,a.Z)(h,p.details,t.className)}))}}}]);